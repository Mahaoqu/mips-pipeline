# 计算机组成原理 设计指导

在本指导书的设计中，流水线的每级都分成两个部分：组合逻辑和时序逻辑部分(当然这种划分不是严格的，例如 IF 和 WB 就很特殊)，组合逻辑的输出传递到时序逻辑的输入。每一级的组合逻辑接受上一级的时许逻辑的输出，同时组 合逻辑的输出传递到本级的时序逻辑部分。

### 五级流水线结构
1. 取指：**IF** (Instruction Fetch)
2. 译码：**ID** (Instruction Decode)
3. 执行：**EX** (Execute)
4. 访存：**MEM** (Memory)
5. 写回：**WB** (Write back)

### 准备工作
总线宽度的定义我们 放在 global.v 文件中。
在 MIPS 指令集中，操作码、FUNCT 等都是人为定义的。把这些“magic code” 写成 Verilog 宏定义的形式有助于提高代码的可读性。因此我们把这些定义 分类放在多个文件里。

**op_def.v** ：定义 OP 字段内容
**funct_def.v** ：定义 SPECIAL 指令中 FUNCT 字段的内容
**regimm_def.v** ：定义REGIMM类指令中rt字段的内容 
**cop0_def.v** ：定义 COP0 操作指令中相关内容

注意到在五级流水线中存在 4 个时序逻辑的部分：**IF_ID**、**ID_EX**、**EX_MEM**、 **MEM_WB**。这些部分的工作只是在时钟上升沿时，把输入传递给输出。显然 它们的功能是高度一致的，只有宽度上的区别。这里在实现时可以考虑使用 Verilog 的 **带参数模块**。

这里我们可以用到 Vivado 的 Design Block 功能：用户只需要绘制模块之间的连线，Vivado 会自动生成对应 的模块。

### 外围模块
以下模块的接口定义见指导书。
**ROM** 部分用于保存我们预先编译好的程序。CPU 上电运行后，从 ROM 的 0 号地址读取第一条指令执行。在这里为了简化，我们把 ROM 设计为异步的组合 逻辑：给出一个地址，在 ROM 的输出端口就立即得到对应的指令。

**RAM** 用于保存数据。RAM 的设计更复杂一些：读取是异步的，给出地址就 得到数据;写入是同步的，只有当时钟上边沿来临时才能做写入。因此 RAM 的 接口更多：

**RegFile** 是 MIPS 汇编中使用到的 32 个通用寄存器。考虑到很多 MIPS 指令都 有两个寄存器参数，我们给 RegFile 设计两个读端口和一个写端口。寄存器的设 计和单周期 CPU 的类似，读数据是异步的，给出寄存器编号就得到输出;写数据 是同步的，只有时钟边沿来临时才能写入数据。其中，译码(ID)阶段需要读数 据的功能，写回(WB)阶段需要写数据的功能。

### 取指（IF）：
取指阶段的核心部件是 PC。除了 PC 之外就只剩下 IF 与 ID 之间的时序逻辑 部分。PC 的结构很简单，它的主要功能是把指令地址传递给 ROM。
PC => IF_ID

### 译码（ID）：
译码阶段的主要工作是：解析从 IF 传递过来的指令内容;根据需要从 RegFile 中拿到对应寄存器的值;生成后续阶段(EX、MEM、WB)需要的控制信号。因 而 ID 阶段有 3 个部件：ID 本身的组合逻辑(ID.v)、寄存器 RegFile 和时序逻辑 ID_EX。
PC => IF_ID => ID => Regfile => ID_EX

### 执行（EX）：
目前 EX 阶段的主要工作是执行运算并传出地址。在 ID 阶段我们已经给出了 操作码、操作数以及写入寄存器的信号和地址。也就是说，结果放到哪里我们已 经在 ID 阶段指定了，EX 要做的就是计算出结果。

### 访存（MEM）：
因为我们暂时没有实现访存阶段的指令，所以这里的组合逻辑部分只是简单
地把输入传递到输出即可。对应的 MEM_WB 也是和其他的时序逻辑模块一样。

### 写回（WB）：
最后一部分 WB 没有组合逻辑，只需要把 MEM_WB 的三根信号接入 RegFile 即可(直接在 Diagram 中操作)。


由于采用了高度的流水线，结果产生了一些对程序员来说可见的效应，需要注意。最重要的两个效应就是*分支延迟效应*和*载入延迟效应*。

1. 任何一个分支跳转语句后面的那条语句叫做**分支延迟槽**。实际上在程序执行到分支语句时，当他刚把要跳转到的地址填充好（到代码计数器里），还没完成本条指令，分支语句后面的那个指令就执行了。这是因为流水线效应，几条指令同时在执行，只是处于不同的阶段。具体看书上说提前半条指令执行，没看懂。分支延迟槽常用被利用起来完成一些参数初始化等相关工作，而不是被浪费了。
2. 载入延迟是这样的。当执行一条从内存中载入数据的命令时，是先载入到**高速缓存**中，然后再取到寄存器中，这个过程相对来说是比较慢的。在这个过程完成之前，可能已经有几条在流水线上的指令被执行了。这几条在载入指令后被执行的指令就被称作载入延迟槽。现在就有一个问题，如果后面这几条指令要用到载入指令所载入的那个数据怎么办？一个通用的办法是，把**内部锁**加在数据载入过程上，这样，当后面的指令要用这条指令时，就只有先停止运行（在ALU阶段），等这条数据载入指令完成了后再开始运行。

## MIPS 指令集分类：

R 类型： `src <op> tgt -> dest`
| OP(6) | RS(5) | RT(5) | RD(5) | SHAMT(5) | FUNCT(6) |

I 类型： `src(immdiate) -> target`
| OP(6) | RS(5) | RT(5) |        IMMEDIATE(16)        |

J 类型： `PC -> Addr`
| OP(6) |                ADDRESS(26)                  |

`rs` -> Source 源寄存器

`rt` -> Target 目标寄存器

`rd` -> Destination 终点寄存器

在I型和R型指令中，目标寄存器同时也是终点寄存器。

## 寄存器：

|  Number   | Name  |    Function    |
| :-------: | :---: | :------------: |
|    $0     | zero  |       0        |
|    $1     |  at   |    asm-temp    |
|  \$2-\$3  | v0-v1 |     value      |
|  \$4-\$7  | a0-a3 |    argument    |
| \$8-\$15  | t0-t7 |      temp      |
| \$16-\$23 | s0-s7 |     saved      |
| \$24-\$25 | t8-t9 |      temp      |
| \$26-\$27 | k0-k1 |   exception    |
|    $28    |  gp   | global pointer |
|    $29    |  sp   | stack pointer  |
|    $30    | s8/fp | frame pointer  |
|    $31    |  ra   | return address |

\$0：即\$zero，该寄存器总是返回零，为0这个有用常数提供了一个简洁的编码形式。使用伪指令可以简化任务，汇编程序提供了比硬件更丰富的指令集。

\$1：即\$at，该寄存器为汇编保留，由于I型指令的立即数字段只有16位，在加载大常数时，编译器或汇编程序需要把大常数拆开，然后重新组合到寄存器里。比如加载一个32位立即数需要` lui`（装入高位立即数）和`addi`两条指令。像MIPS程序拆散和重装大常数由汇编程序来完成，汇编程序必需一个临时寄存器来重组大常数，这也是为汇编保留$at的原因之一。

\$2-\$3：（\$v0-\$v1）用于子程序的非浮点结果或返回值，对于子程序如何传递参数及如何返回，MIPS范围有一套约定，堆栈中少数几个位置处的内容装入CPU寄存器，其相应内存位置保留未做定义，当这两个寄存器不够存放返回值时，编译器通过内存来完成。

$4-\$7：（\$a0-\$a3）用来传递前四个参数给子程序，不够的用堆栈。a0-a3和v0-v1以及\$ra一起来支持子程序／过程调用，分别用以传递参数，返回结果和存放返回地址。当需要使用更多的寄存器时，就需要堆栈（stack)了，MIPS编译器总是为参数在堆栈中留有空间以防有参数需要存储。

\$8-\$15：（\$t0-\$t7）临时寄存器，子程序可以使用它们而不用保留。

\$16-\$23：（\$s0-\$s7）保存寄存器，在过程调用过程中需要保留（被调用者保存和恢复，还包括\$fp和\$ra），MIPS提供了临时寄存器和保存寄存器，这样就减少了寄存器溢出（spilling，即将不常用的变量放到存储器的过程)，编译器在编译一个叶（leaf)过程（不调用其它过程的过程）的时候，总是在临时寄存器分配完了才使用需要保存的寄存器。

\$24-\$25：（\$t8-\$t9）同（\$t0-\$t7）

\$26-\$27：（\$k0-\$k1）为操作系统／异常处理保留，至少要预留一个。异常（或中断）是一种不需要在程序中显示调用的过程。MIPS有个叫异常程序计数器（exception program counter，EPC）的寄存器，属于**CP0寄存器**，用于保存造成异常的那条指令的地址。查看控制寄存器的唯一方法是把它复制到通用寄存器里，指令`mfc0`（move from system control）可以将EPC中的地址复制到某个通用寄存器中，通过跳转语句`jr`，程序可以返回到造成异常的那条指令处继续执行。MIPS程序员都必须保留两个寄存器\$k0和\$k1，供操作系统使用。发生异常时，这两个寄存器的值不会被恢复，编译器也不使用k0和k1，异常处理函数可以将返回地址放到这两个中的任何一个，然后使用`jr`跳转到造成异常的指令处继续执行。

\$28：(\$gp)为了简化静态数据的访问，MIPS软件保留了一个寄存器：全局指针gp(global  pointer，$gp)，全局指针只想静态数据区中的运行时决定的地址，在存取位于\$gp值上下32KB范围内的数据时，只需要一条以\$gp为基指针的指令即可。在编译时，数据须在以\$gp为基指针的64KB范围内。

\$29：（\$sp）MIPS硬件并不直接支持堆栈，你可以把它用于别的目的，但为了使用别人的程序或让别人使用你的程序， 还是要遵守这个约定的，但这和硬件没有关系。

 \$30：（\$fp）GNU MIPS C编译器使用了帧指针(frame pointer)，而SGI的C编译器没有使用，而把这个寄存器当作保存寄存器使用（$s8)，这节省了调用和返回开销，但增加了代码生成的复杂性。

 \$31：（\$ra）存放返回地址，MIPS有个`jal`（jump-and-link，跳转并链接）指令，在跳转到某个地址时，把下一条指令的地址放到\$ra中。用于支持子程序，例如调用程序把参数放到\$a0~\$a3，然后`jal X`跳到X过程，被调过程完成后把结果放到\$v0，\$v1，然后使用`jr $ra`返回。

## MIPS 指令：

| R-type | op      | rs    | rt    | rd    | shamt | func   | Description                        |
| :----- | :------ | :---- | :---- | :---- | :---- | :----- | :--------------------------------- |
| `add`  | 000000  | rs    | rt    | rd    | 00000 | 100000 | 补码寄存器加                       |
| `addu` | 000000  | rs    | rt    | rd    | 00000 | 100001 | 无符号寄存器加                     |
| `sub`  | 000000  | rs    | rt    | rd    | 00000 | 100010 | 补码寄存器减                       |
| `subu` | 000000  | rs    | rt    | rd    | 00000 | 100011 | 无符号寄存器减                     |
| `and`  | 000000  | rs    | rt    | rd    | 00000 | 100100 | 按位与                             |
| `or`   | 000000  | rs    | rt    | rd    | 00000 | 100101 | 按位或                             |
| `xor`  | 000000  | rs    | rt    | rd    | 00000 | 100110 | 按位异或                           |
| `nor`  | 000000  | rs    | rt    | rd    | 00000 | 100111 | 按位或非                           |
| `slt`  | 000000  | rs    | rt    | rd    | 00000 | 101010 | 补码小于比较设置条件               |
| `sltu` | 000000  | rs    | rt    | rd    | 00000 | 101000 | 无符号小于比较设置条件             |
| `sll`  | 000000  | 00000 | rt    | rd    | shamt | 000000 | 左移立即数                         |
| `srl`  | 000000  | 00000 | rt    | rd    | shamt | 000010 | 逻辑右移立即数                     |
| `sra`  | 000000  | 00000 | rt    | rd    | shamt | 000011 | 算术右移立即数                     |
| `sllv` | 000000  | rs    | rt    | rd    | shamt | 000100 | 左移寄存器                         |
| `srlv` | 000000  | rs    | rt    | rd    | 00000 | 000110 | 逻辑右移寄存器                     |
| `srav` | 000000  | rs    | rt    | rd    | 00000 | 000111 | 算数右移寄存器                     |
| `jr`   | 000000  | rs    | 00000 | 00000 | 00000 | 001000 | 跳转到寄存器                       |
| `mfhi` | 000000  | 00000 | 00000 | rd    | 00000 | 001010 | 从hi寄存器传送                     |
| `mthi` | 000000  | rs    | 00000 | 00000 | 00000 | 001011 | 传送至hi寄存器                     |
| `mflo` | 000000  | 00000 | 00000 | rd    | 00000 | 001100 | 从lo寄存器传送                     |
| `mtlo` | 000000  | rs    | 00000 | 00000 | 00000 | 001101 | 传送至lo寄存器                     |
| `mult` | 000000  | rs    | rt    | 00000 | 00000 | 010010 | 寄存器乘法，低、高位分别存入lo和hi   |
| `mul`  | 011100  | rs    | rt    | rd    | 00000 | 000010 | 乘法，低32位存入rd中                |
| `div`  | 000000  | rs    | rt    | 00000 | 00000 | 011010 | 除法，商存入lo，余数存入hi           |
| `divu` | 000000  | rs    | rt    | 00000 | 00000 | 011011 | 无符号除法                          |
|        |         |       |       |       |       |        |                                    |


| I-type  | op     | rs    | rt    | immediate | Description                          |
| ------- | ------ | ----- | ----- | --------- | ------------------------------------ |
| `addi`  | 001000 | rs    | rt    | immediate | 补码立即数加                         |
| `addiu` | 001001 | rs    | rt    | immediate | 无符号立即数加                       |
| `slti`  | 001010 | rs    | rt    | immediate | 补码小于立即数设置条件               |
| `sltiu` | 001011 | rs    | rt    | immediate | 无符号小于立即数设置条件             |
| `andi`  | 001100 | rs    | rt    | immediate | 立即数按位与                         |
| `ori`   | 001101 | rs    | rt    | immediate | 立即数按位或                         |
| `xori`  | 001110 | rs    | rt    | immediate | 立即数按位异或                       |
| `lui`   | 001111 | 00000 | rt    | immediate | 将 16 位立即数放到目的寄存器高 16 位 |
| `lw`    | 100011 | rs    | rt    | offset    | 以寄存器+偏移寻址从内存读            |
| `sw`    | 101011 | rs    | rt    | offset    | 以寄存器+偏移寻址向内存写            |
| `beq`   | 000100 | rs    | rt    | offset    | 相等则相对跳转                       |
| `bne`   | 000101 | rs    | rt    | offset    | 不相等则相对跳转                     |
| `blez`  | 000110 | rs    | 00000 | offset    | 小于等于零则相对跳转                 |
| `bgtz`  | 000111 | rs    | 00000 | offset    | 大于零则相对跳转                     |




| J-Type | op     | address | Description                          |
| ------ | ------ | ------- | ------------------------------------ |
| `j`    | 000010 | address | 无条件跳转                           |
| `jal`  | 000011 | address | 子程序调用，返回地址置于31号寄存器中 |



#### 整数算术和逻辑指令

加、减（补码/浮点数、立即数/寄存器）

与、或、异或、取反（立即数/寄存器）

左移、右移（算数、逻辑）、循环右移

乘、除（带溢出/不带溢出），使用lo/hi寄存器

乘加、乘减

#### 常数操作

小于置位（补码/无符号，立即数/寄存器）

#### 分支操作

相等分支、大于零、大于等于零、小于零、小于等于零

协处理器分支

#### 跳转操作

无条件跳转（立即数/寄存器）、跳转并保存返回值到寄存器（立即数/寄存器）

#### 陷阱指令

相等、等于立即数、不相等、不等于立即数、{大于，小于}{，等于}{补码、无符号}立即数

#### 取数指令

取字节（补码/无符号）、取半字（补码/无符号）、取字

协处理器取字

#### 保存指令

存字节（补码/无符号）、存半字（补码/无符号）、存字

#### 数据传送指令

从hi/lo寄存器传送、传送至hi/lo寄存器

从协处理器0/1中传送、传送至协处理器0/1

非零条件传送、零条件传送

#### 浮点运算指令

略

#### 异常和中断指令

异常返回、系统调用、跳出、空操作

## 特殊指令

在 MIPS 处理器中，协处理器扮演了很重要的角色。包括异常、中断和浮点数在内的许多功能都是由协处理器实现的。其中，第 0 个协处理器 CP0 就负责MIPS 处理器的异常和中断功能。 





## 参考

[MIPS](https：//blog.csdn.net/sdustliyang/article/details/6946624)

[CP0协处理器](https：//blog.csdn.net/ieya/article/details/4695098)

[MISP参考](https://blog.csdn.net/frozenshore/article/details/44706299)

